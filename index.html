<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta viewport="width=device-width, initial-scale=1.0">
		<!--
			Based on:

			Experimenting With speechSynthesis
			by Aaron Gustafson
			Smashing Magazine
			2017-02-14
			
			https://www.smashingmagazine.com/2017/02/experimenting-with-speechsynthesis/

			---

			And the Mozilla Developer Network (MDN) SpeechSynthesis API documentation:

			https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesis
		-->
		<title>Speaker</title>
		<style>
			body {
				font-family: sans-serif, serif;
			}

			#app {
				margin: 0 auto;
				max-width: 1000px;
				width: 100%;
			}

			#app h1 {
				text-align: center;
			}

			#app fieldset {
				border: 0;
				padding: 20px;
			}

			#app fieldset legend {
				font-weight: bold;
			}

			#app fieldset ul {
				list-style: none;
				margin: 0;
				padding: 0;
			}

			#app fieldset li {
				margin-bottom: 15px;
			}

			#app fieldset li label {
				display: inline-block;
				max-width: 230px;
				width: 25%;
			}

			#app fieldset li input,
			#app fieldset li select 
			{
				display: inline-block;
				max-width: 700px;
				width: 75%;
			}

			#app fieldset li input[type="text"] {
				max-width: 696px;
			}

			#app fieldset textarea {
				max-width: 996px;
				width: 100%;
			}

			#app fieldset #controls {
				margin: 20px 0;
			}
			
			#controls li {
				display: inline-block;
			}
		</style>
	</head>

	<body>

		<div id="app">
			<h1>Speaker</h1>

			<form>
				<fieldset>
					<legend>Speaker Preferences</legend>

					<ul>
						<li>
							<label for="voice">Voice:</label>
							<select name="Voice" id="voice">
								<option>Select a voice...</option>
							</select>
						</li>

						<li>
							<label for="rate">Speech Rate:</label>
							<input type="range" name="Rate" id="rate" min="0.1" max="10" step="0.1" value="1.0" list="rates">
							<datalist id="rates">
								<option value="1.0"></option>
							</datalist>
						</li>

						<li>
							<label for="pitch">Pitch:</label>
							<input type="range" name="Pitch" id="pitch" min="0" max="2" step="0.1" value="1.0" list="pitches">
							<datalist id="pitches">
								<option value="1.0"></option>
							</datalist>
						</li>
					</ul>
				</fieldset>

				<fieldset>
					<legend>Text to Speak</legend>

					<div>
						<label for="speaktext" style="display: none;">Enter text to speak</label>
						<textarea name="TextToSpeak" id="speaktext" cols="100" rows="5"></textarea>
					</div>

					<ul id="controls">
						<li><button type="button" id="doSpeakText">Speak</button></li>
						<li><button type="button" id="doPauseSpeaking">Pause</button></li>
						<li><button type="button" id="doStopSpeaking">Stop</button></li>
						<li><button type="button" id="doClearText">Clear Text</button></li>
						<li><progress id="speechProgress" max="100" value="0">0/100</progress></li>
					</ul>
				</fieldset>
			</form>
		</div>

		<script>

			const speechEngine = window.speechSynthesis

			// Firefox returns a *CORNUCOPIA* of voices... and Chrome needs an event listener to record the list
			// English language options are "en-029", "en-GB", "en-GB-SCOTLAND", "en-GB-X-GBCLAN", "en-GB-X-GBCWMD", "en-GB-X-RP", "en-US", "en-US-NYC"
			let voicelist = speechEngine.getVoices() 
			speechEngine.addEventListener("voiceschanged", () => {
				voicelist = speechEngine.getVoices()
				speaker.setVoices(voicelist)
				app.populateVoiceList(speaker.voices)
			})

			class App {
				ui = {
					container: undefined,
					buttons: {
						speak: undefined,
						pause: undefined,
						stop: undefined,
						clear: undefined,
					},
					inputs: {
						voice: undefined,
						rate: undefined,
						pitch: undefined,
						text: undefined,
					},	
					progress: undefined,
				}

				constructor(appSelector) {
					this.ui.container = document.querySelector(appSelector)

					this.ui.inputs.voice = this.ui.container.querySelector("#voice")
					this.ui.inputs.rate = this.ui.container.querySelector("#rate")
					this.ui.inputs.pitch = this.ui.container.querySelector("#pitch")
					this.ui.inputs.text = this.ui.container.querySelector("#speaktext")

					this.ui.buttons.speak = this.ui.container.querySelector("#doSpeakText")
					this.ui.buttons.pause = this.ui.container.querySelector("#doPauseSpeaking")
					this.ui.buttons.stop = this.ui.container.querySelector("#doStopSpeaking")
					this.ui.buttons.clear = this.ui.container.querySelector("#doClearText")

					this.ui.progress = this.ui.container.querySelector("#speechProgress")
				}

				populateVoiceList(voices) {
					const voiceKeys = Object.keys(voices)

					if (voiceKeys.length > 0) {
						let voiceItems = []

						voiceKeys.forEach((k) => {
							voices[k].forEach((v) => {
								let friendlyLang = "English"
								switch (v.lang) {
									case "en-GB":
										friendlyLang = "English (Britain)"
										break
									case "en-GB-SCOTLAND":
										friendlyLang = "English (Scotland)"
										break
									case "en-US":
										friendlyLang = "English (US)"
										break
									case "en-US-NYC":
										friendlyLang = "English (NYC)"
										break
									default:
										// PASS:
								}

								let friendlyName = v.voiceURI.search("moz-tts") >= 0
									? (v.voiceURI.split("+").length > 1 ? v.voiceURI.split("+")[1].replace(`?${v.lang}`, "") : v.voiceURI)
									: v.voiceURI

								if (friendlyName.length > 0) {
									friendlyName = friendlyName.substring(0, 1).toUpperCase() + friendlyName.substring(1)
								}

								voiceItems.push({
									lang: friendlyLang,
									uri: v.voiceURI,
									name: friendlyName 
								})
							})
						})

						if (voiceItems.length > 0) {
							voiceItems.sort((a, b) => {
								if (a.lang < b.lang) {
									return -1
								}
								else if (a.lang > b.lang) {
									return 1
								}
								else {
									if (a.name < b.name) {
										return -1
									}
									else if (a.name > b.name) {
										return 1
									}
								}

								return 0
							})

							let currentLang = ""
							let currentOptGroup = undefined
							voiceItems.forEach((i) => {
								if (voiceItems.length > 10) {
									if (currentLang !== i.lang) {
										if (currentOptGroup !== undefined) {
											this.ui.inputs.voice.appendChild(currentOptGroup)
										}
										
										currentOptGroup = document.createElement("optgroup")
										currentOptGroup.label = i.lang
									}
								}

								let opt = document.createElement("option")
								opt.value = i.uri
								opt.innerHTML = i.name

								if (currentOptGroup !== undefined) {
									currentOptGroup.append(opt)
								}
								else {
									this.ui.inputs.voice.appendChild(opt)
								}
								
								currentLang = i.lang
							}) 
						}
					}

				}
			}

			class Speaker {
				voices = {
					"en-GB": [],
					"en-GB-SCOTLAND": [],
					"en-US": [],
					"en-US-NYC": [],
				} 

				constructor() {
					// PASS: 
				}

				setVoices(voicelist) {
					this.voices["en-GB"] = voicelist.filter((v) => v.lang === "en-GB")
					this.voices["en-GB-SCOTLAND"] = voicelist.filter((v) => v.lang === "en-GB-SCOTLAND")
					this.voices["en-US"] = voicelist.filter((v) => v.lang === "en-US")
					this.voices["en-US-NYC"] = voicelist.filter((v) => v.lang === "en-US-NYC") 
				}
			}

			const app = new App("#app")
			const speaker = new Speaker()
			
			// Firefox will be fine here, Chrome will use the event listener above...
			speaker.setVoices(voicelist) 
			app.populateVoiceList(speaker.voices)
		</script>

	</body>
</html>
